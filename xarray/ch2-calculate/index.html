<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222" media="(prefers-color-scheme: light)"><meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.2.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/bj.apple-touch.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/bj.medium.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/bj.small.png"><link rel="mask-icon" href="/images/bj.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://fonts.loli.net/css?family=Comic+Sans+MS:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css" integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin="anonymous"><script class="next-config" data-name="main" type="application/json">{"hostname":"buujun.fun","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.12.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":"flat","show_result":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":false,"nav":{"gitalk":{"order":-1}},"activeClass":"gitalk"},"stickytabs":false,"motion":{"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script><meta name="description" content="本文主要介绍 Xarray 相关的计算，包括：基础计算、分组计算、重采样计算、滑动计算以及多项式回归"><meta property="og:type" content="article"><meta property="og:title" content="Xarray - 计算"><meta property="og:url" content="https://buujun.fun/xarray/ch2-calculate/index.html"><meta property="og:site_name" content="BUUJUN&#39;s Notes"><meta property="og:description" content="本文主要介绍 Xarray 相关的计算，包括：基础计算、分组计算、重采样计算、滑动计算以及多项式回归"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2022-07-31T21:36:37.000Z"><meta property="article:modified_time" content="2022-09-26T03:07:17.042Z"><meta property="article:author" content="BUUJUN WANG"><meta property="article:tag" content="python"><meta property="article:tag" content="numpy"><meta property="article:tag" content="pandas"><meta property="article:tag" content="matplotlib"><meta property="article:tag" content="xarray"><meta name="twitter:card" content="summary"><link rel="canonical" href="https://buujun.fun/xarray/ch2-calculate/"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://buujun.fun/xarray/ch2-calculate/","path":"xarray/ch2-calculate/","title":"Xarray - 计算"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>Xarray - 计算 | BUUJUN's Notes</title><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript><style>mjx-container[jax=SVG]{direction:ltr}mjx-container[jax=SVG]>svg{overflow:visible}mjx-container[jax=SVG][display=true]{display:block;text-align:center;margin:1em 0}mjx-container[jax=SVG][justify=left]{text-align:left}mjx-container[jax=SVG][justify=right]{text-align:right}g[data-mml-node=merror]>g{fill:red;stroke:red}g[data-mml-node=merror]>rect[data-background]{fill:#ff0;stroke:none}g[data-mml-node=mtable]>line[data-line]{stroke-width:70px;fill:none}g[data-mml-node=mtable]>rect[data-frame]{stroke-width:70px;fill:none}g[data-mml-node=mtable]>.mjx-dashed{stroke-dasharray:140}g[data-mml-node=mtable]>.mjx-dotted{stroke-linecap:round;stroke-dasharray:0,140}g[data-mml-node=mtable]>svg{overflow:visible}[jax=SVG] mjx-tool{display:inline-block;position:relative;width:0;height:0}[jax=SVG] mjx-tool>mjx-tip{position:absolute;top:0;left:0}mjx-tool>mjx-tip{display:inline-block;padding:.2em;border:1px solid #888;font-size:70%;background-color:#f8f8f8;color:#000;box-shadow:2px 2px 5px #aaa}g[data-mml-node=maction][data-toggle]{cursor:pointer}mjx-status{display:block;position:fixed;left:1em;bottom:1em;min-width:25%;padding:.2em .4em;border:1px solid #888;font-size:90%;background-color:#f8f8f8;color:#000}foreignObject[data-mjx-xml]{font-family:initial;line-height:normal;overflow:visible}.MathJax path{stroke-width:3}mjx-container[display=true]{overflow:auto hidden}mjx-container[display=true]+br{display:none}</style></head><body itemscope itemtype="http://schema.org/WebPage"><div class="headband"></div><main class="main"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title">BUUJUN's Notes</p><i class="logo-line"></i></a><p class="site-subtitle" itemprop="description">love and share</p></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">15</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">3</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">39</span></a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-links"><a href="/links/" rel="section"><i class="fa fa-link fa-fw"></i>友链</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class="search-result-icon"><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></div><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E8%AE%A1%E7%AE%97"><span class="nav-number">1.</span> <span class="nav-text">基础计算</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E8%AE%A1%E7%AE%97"><span class="nav-number">1.1.</span> <span class="nav-text">基本计算</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4-%E5%92%8C-numpy-%E5%87%BD%E6%95%B0"><span class="nav-number">1.1.1.</span> <span class="nav-text">加减乘除 和 numpy 函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#apply_ufunc-%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">1.1.2.</span> <span class="nav-text">apply_ufunc 函数的使用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%99%8D%E7%BB%B4%E8%AE%A1%E7%AE%97-mean-sum-min-max-std-"><span class="nav-number">1.2.</span> <span class="nav-text">降维计算： mean, sum, min, max, std, ...</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%B9%E6%8D%AE-axis-%E9%99%8D%E7%BB%B4"><span class="nav-number">1.2.1.</span> <span class="nav-text">根据 axis 降维</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%B9%E6%8D%AE-dim-%E9%99%8D%E7%BB%B4"><span class="nav-number">1.2.2.</span> <span class="nav-text">根据 dim 降维</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8E%A7%E5%88%B6%E7%BC%BA%E5%A4%B1%E5%80%BC-skipna"><span class="nav-number">1.2.3.</span> <span class="nav-text">控制缺失值 skipna</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%83%E4%B9%A0---1"><span class="nav-number">1.2.4.</span> <span class="nav-text">练习 - 1</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B9%BF%E6%92%AD"><span class="nav-number">1.3.</span> <span class="nav-text">广播</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B5%8B%E6%9D%83%E9%99%8D%E7%BB%B4"><span class="nav-number">1.4.</span> <span class="nav-text">赋权降维</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%BA%90%E6%95%B0%E6%8D%AE%E5%AD%98%E5%9C%A8-%E7%BC%BA%E5%A4%B1%E5%80%BC%E5%92%8C%E6%9F%90%E4%BA%9B%E7%89%B9%E6%AE%8A%E8%AE%A1%E7%AE%97%E7%9A%84%E6%83%85%E5%86%B5"><span class="nav-number">1.4.1.</span> <span class="nav-text">源数据存在 缺失值和某些特殊计算的情况</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E9%99%85%E6%A1%88%E4%BE%8B%E5%B9%B3%E5%9D%87sst%E7%9A%84%E8%AE%A1%E7%AE%97"><span class="nav-number">1.4.2.</span> <span class="nav-text">实际案例：平均SST的计算</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#groupby-%E5%88%86%E7%BB%84"><span class="nav-number">2.</span> <span class="nav-text">Groupby 分组</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%B9%E6%8D%AE%E6%97%B6%E9%97%B4%E5%88%86%E7%BB%84"><span class="nav-number">2.1.</span> <span class="nav-text">根据时间分组</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E6%97%B6%E9%97%B4%E5%8F%98%E9%87%8F%E7%9A%84-%E5%BE%85%E7%B4%A2%E5%BC%95%E5%AF%B9%E8%B1%A1"><span class="nav-number">2.1.1.</span> <span class="nav-text">创建时间变量的 待索引对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%B9%E6%8D%AE%E6%97%B6%E9%97%B4%E7%B4%A2%E5%BC%95%E5%88%9B%E5%BB%BA-groupby%E5%AF%B9%E8%B1%A1"><span class="nav-number">2.1.2.</span> <span class="nav-text">根据时间索引，创建 groupby对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%AD%E4%BB%A3%E8%AE%BF%E9%97%AE-groupby%E5%AF%B9%E8%B1%A1"><span class="nav-number">2.1.3.</span> <span class="nav-text">迭代访问 groupby对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%90%E4%B8%AA%E8%AE%BF%E9%97%AE-groupby%E5%AF%B9%E8%B1%A1"><span class="nav-number">2.1.4.</span> <span class="nav-text">逐个访问 groupby对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9F%A5%E6%89%BE%E5%90%84%E4%B8%AA%E5%88%86%E7%BB%84%E4%B8%AD%E5%AF%B9%E5%BA%94%E5%85%83%E7%B4%A0%E5%9C%A8%E5%8E%9F%E5%A7%8B%E6%95%B0%E6%8D%AE%E4%B8%AD%E9%94%AE%E7%9A%84%E4%BD%8D%E7%BD%AE"><span class="nav-number">2.1.5.</span> <span class="nav-text">查找各个分组中对应元素在原始数据中键的位置</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E7%AE%B1binning"><span class="nav-number">2.2.</span> <span class="nav-text">分箱（Binning）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%B9%E6%8D%AE%E5%88%86%E7%AE%B1%E5%88%9B%E5%BB%BA-groupby%E5%AF%B9%E8%B1%A1"><span class="nav-number">2.2.1.</span> <span class="nav-text">根据分箱，创建 groupby对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%AD%E4%BB%A3%E8%AE%BF%E9%97%AE-groupby-%E5%AF%B9%E8%B1%A1"><span class="nav-number">2.2.2.</span> <span class="nav-text">迭代访问 groupby 对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%90%E4%B8%AA%E8%AE%BF%E9%97%AE-groupby-%E5%AF%B9%E8%B1%A1"><span class="nav-number">2.2.3.</span> <span class="nav-text">逐个访问 groupby 对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9F%A5%E7%9C%8B%E5%88%86%E7%AE%B1%E5%90%8D%E7%A7%B0%E5%8F%8A%E5%85%B6%E6%95%B0%E6%8D%AE%E5%9C%A8%E5%8E%9F%E5%A7%8B%E6%95%B0%E6%8D%AE%E5%AF%B9%E5%BA%94%E7%9A%84%E4%BD%8D%E7%BD%AE"><span class="nav-number">2.2.4.</span> <span class="nav-text">查看分箱名称及其数据在原始数据对应的位置</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#groupby-%E7%9A%84%E5%BA%94%E7%94%A8"><span class="nav-number">2.3.</span> <span class="nav-text">Groupby 的应用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B4%AF%E8%AE%A1%E9%99%8D%E7%BB%B4"><span class="nav-number">2.3.1.</span> <span class="nav-text">累计（“降维”）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BD%AC%E6%8D%A2"><span class="nav-number">2.3.2.</span> <span class="nav-text">转换</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#resample%E9%87%8D%E9%87%87%E6%A0%B7"><span class="nav-number">3.</span> <span class="nav-text">Resample重采样</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#coarsen%E7%B2%97%E5%8C%96"><span class="nav-number">4.</span> <span class="nav-text">Coarsen（粗化）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#rolling-%E6%BB%91%E5%8A%A8%E5%B9%B3%E5%9D%87"><span class="nav-number">5.</span> <span class="nav-text">Rolling 滑动平均</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BA%86%E6%9B%B4%E5%A5%BD%E7%9A%84%E8%AF%B4%E6%98%8E-rolling-%E7%9A%84%E4%BD%9C%E7%94%A8%E4%B8%8B%E9%9D%A2%E4%B8%BE%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E4%BE%8B%E5%AD%90%E8%AF%B4%E6%98%8E%E5%85%B6%E5%8A%9F%E8%83%BD"><span class="nav-number">5.1.</span> <span class="nav-text">为了更好的说明 Rolling 的作用，下面举一个简单的例子说明其功能</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E6%80%A7%E5%A4%9A%E9%A1%B9%E5%BC%8F%E5%9B%9E%E5%BD%92"><span class="nav-number">6.</span> <span class="nav-text">线性多项式回归</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="BUUJUN WANG" src="/images/bj.avatar.gif"><p class="site-author-name" itemprop="name">BUUJUN WANG</p><div class="site-description" itemprop="description"></div></div><div class="site-state-wrap site-overview-item animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">39</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">3</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">15</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author site-overview-item animated"><span class="links-of-author-item"><a href="https://gitee.com/buujun" title="GitHub → https:&#x2F;&#x2F;gitee.com&#x2F;buujun" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a> </span><span class="links-of-author-item"><a href="mailto:wangbj27@mail2.sysu.edu.cn" title="E-Mail → mailto:wangbj27@mail2.sysu.edu.cn" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a></span></div><div class="sidebar-line"></div><div class="links-of-blogroll motion-element links-of-blogroll-block"><div class="links-of-blogroll-title"><i class="fa fa-history fa-" aria-hidden="true"></i> <a href="/archives" title="近期文章" target="_blank">近期文章</a></div><ul class="links-of-blogroll-list"><li><a href="/matplotlib/01_font_set/" title="Matplotlib - 字体设置" target="_blank">Matplotlib - 字体设置</a></li><li><a href="/notebooks/%E4%B8%93%E4%B8%9A%E5%90%8D%E8%AF%8D/" title="整理 - 常用的气象专业名词" target="_blank">整理 - 常用的气象专业名词</a></li><li><a href="/Linux/%E7%B3%BB%E7%BB%9F%E9%87%8D%E8%A3%85/" title="Ubuntu - 系统重装" target="_blank">Ubuntu - 系统重装</a></li></ul></div><div class="sidebar-line"></div><div class="links-of-blogroll motion-element links-of-blogroll-block"><div class="links-of-blogroll-title"><i class="fa-solid fa-paperclip fa-" aria-hidden="true"></i> <a href="/links" title="常用链接" target="_blank">常用链接</a></div></div><div class="links-of-author site-overview-item animated"><span class="links-of-author-item"><a href="https://music.163.com/" title="Music → https:&#x2F;&#x2F;music.163.com" rel="noopener" target="_blank"><i class="fa fa-compact-disc fa-fw"></i>Music</a> </span><span class="links-of-author-item"><a href="https://www.bilibili.com/" title="Bilibili → https:&#x2F;&#x2F;www.bilibili.com" rel="noopener" target="_blank"><i class="fa-brands fa-bilibili fa-fw"></i>Bilibili</a> </span><span class="links-of-author-item"><a href="https://docs.scipy.org/doc/scipy/reference/index.html" title="SciPy → https:&#x2F;&#x2F;docs.scipy.org&#x2F;doc&#x2F;scipy&#x2F;reference&#x2F;index.html" rel="noopener" target="_blank"><i class="fa fa-calculator fa-fw"></i>SciPy</a> </span><span class="links-of-author-item"><a href="https://docs.xarray.dev/en/stable/api.html" title="Xarray → https:&#x2F;&#x2F;docs.xarray.dev&#x2F;en&#x2F;stable&#x2F;api.html" rel="noopener" target="_blank"><i class="fa fa-cube fa-fw"></i>Xarray</a> </span><span class="links-of-author-item"><a href="https://matplotlib.org/stable/api/axes_api.html" title="Matplotlib → https:&#x2F;&#x2F;matplotlib.org&#x2F;stable&#x2F;api&#x2F;axes_api.html" rel="noopener" target="_blank"><i class="fa fa-chart-pie fa-fw"></i>Matplotlib</a> </span><span class="links-of-author-item"><a href="https://pytorch.org/docs/stable/nn.html" title="PyTorch → https:&#x2F;&#x2F;pytorch.org&#x2F;docs&#x2F;stable&#x2F;nn.html" rel="noopener" target="_blank"><i class="fa fa-droplet fa-fw"></i>PyTorch</a></span></div></div></div></div><div class="sidebar"><div class="sidebar-music-inner sidebar-nav-active sidebar-toc-active"><div class="links-of-blogroll motion-element links-of-blogroll-block"><div class="links-of-blogroll-title"><i class="fa-solid fa-headphones" aria-hidden="true"></i> 听听看吧</div></div><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="280" height="86" src="//music.163.com/outchain/player?type=2&id=551338024&auto=0&height=66"></iframe></div></div></aside><div class="sidebar-dimmer"></div></header><div class="back-to-top" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up"></i> <span>0%</span></div><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://buujun.fun/xarray/ch2-calculate/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/bj.avatar.gif"><meta itemprop="name" content="BUUJUN WANG"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="BUUJUN's Notes"><meta itemprop="description" content=""></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="Xarray - 计算 | BUUJUN's Notes"><meta itemprop="description" content=""></span><header class="post-header"><h1 class="post-title" itemprop="name headline">Xarray - 计算</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2022-07-31 21:36:37" itemprop="dateCreated datePublished" datetime="2022-07-31T21:36:37Z">2022-07-31</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2022-09-26 03:07:17" itemprop="dateModified" datetime="2022-09-26T03:07:17Z">2022-09-26</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/python/" itemprop="url" rel="index"><span itemprop="name">python</span></a></span></span></div></div></header><div class="post-body" itemprop="articleBody"><p>本文主要介绍 Xarray 相关的计算，包括：基础计算、分组计算、重采样计算、滑动计算以及多项式回归</p><span id="more"></span><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> xarray <span class="keyword">as</span> xr</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line">%matplotlib inline</span><br><span class="line"><span class="comment"># 给一个随机数种子，使得每次运行得到的随机数是相同的</span></span><br><span class="line">rng = np.random.default_rng(seed=<span class="number">0</span>)  </span><br><span class="line"><span class="comment"># 数据导入</span></span><br><span class="line">path = <span class="string">".data/sst.mnmean.nc"</span></span><br><span class="line"><span class="comment"># 丢弃一个不必要导入的变量:time_bnds</span></span><br><span class="line">ds = xr.open_dataset(path, drop_variables=[<span class="string">"time_bnds"</span>])</span><br><span class="line"><span class="comment"># 下述代码需几分钟导入数据</span></span><br><span class="line">ds = ds.sel(time=<span class="built_in">slice</span>(<span class="string">"1960"</span>, <span class="string">"2018"</span>)).load()</span><br></pre></td></tr></table></figure><h2 id="基础计算">基础计算</h2><h3 id="基本计算">基本计算</h3><h4 id="加减乘除-和-numpy-函数">加减乘除 和 <strong><em>numpy</em></strong> 函数</h4><p>xarray 的 DataArray 和 DataSet 对象可以无缝地使用计算操作符（如+, -, *, /）和 numpy 数组函数。</p><p>下面我们将海温数据的 摄氏温度 改写为 开尔文温度 为例说明上述问题。<br>可以发现再进行计算操作后，数据集的维度和坐标都没有发生变化。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sst_kelvin = ds.sst+<span class="number">270</span></span><br></pre></td></tr></table></figure><p>下面我们来尝试一下用更为复杂的函数进行计算。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.log(sst_kelvin ** <span class="number">2</span>).coords</span><br></pre></td></tr></table></figure><h4 id="apply_ufunc-函数的使用"><strong><em>apply_ufunc</em></strong> 函数的使用</h4><p>上面可以调用 <strong>np.log(ds)</strong> 并使其在 xarray 中“正常工作”是非常幸运的，但是 并非所有的库都能直接在 xarray 中正常工作 。</p><p><strong><em>xr.apply_ufunc(function, vars)</em></strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xr.apply_ufunc(np.log, sst_kelvin**<span class="number">2</span>).coords</span><br></pre></td></tr></table></figure><p>apply_ufunc 函数功能强大，有很多可选参数以便进行复杂操作</p><p>更多可查阅：<a target="_blank" rel="noopener" href="http://xarray.pydata.org/en/latest/generated/xarray.apply_ufunc.html" class="uri">http://xarray.pydata.org/en/latest/generated/xarray.apply_ufunc.html</a></p><h3 id="降维计算-mean-sum-min-max-std-">降维计算： <strong><em>mean, sum, min, max, std, ...</em></strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sst = ds.sst</span><br></pre></td></tr></table></figure><h4 id="根据-axis-降维">根据 <strong><em>axis</em></strong> 降维</h4><p><strong><em>xarray.mean( axis )</em></strong></p><p>在numpy中，如果要进行对某一维度以某种方式（譬如取最大、小值，平均值）进行降维，可通过指定axis参数实现。比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr = np.arange(<span class="number">20</span>).reshape(<span class="number">5</span>,<span class="number">4</span>)</span><br><span class="line">arr.<span class="built_in">sum</span>(axis = <span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>对于xarray对象，如sst：如果要对时间方向上以平均的方法进行降维，与numpy中的方法类似，可写为</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对第0维度（维度time）以平均的方法进行降维</span></span><br><span class="line">sst.mean(axis = <span class="number">0</span>).coords</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sst.mean(axis = <span class="number">0</span>).plot()</span><br></pre></td></tr></table></figure><p>那么如果要对经纬方向上同时进行降维应当如何写呢？只需要将同时降维的维度号用小括号包含在内即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对第1、2维度（维度lat、lon）以平均的方法进行降维</span></span><br><span class="line">sst.mean(axis=(<span class="number">1</span>, <span class="number">2</span>)).coords</span><br></pre></td></tr></table></figure><p>通过对经纬方向的降维，我们现在得到了一个时间序列，这个时间序列描述了全球平均表面海温（SST）的变化。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sst.mean(axis=(<span class="number">1</span>, <span class="number">2</span>)).plot()</span><br></pre></td></tr></table></figure><p>可以注意到每一年中全球平均海温存在明显的季节振荡（变化），这个季节振荡的去除可利用 <strong>resample</strong> 方法得到，后续将会详细介绍这个功能的使用方法。</p><h4 id="根据-dim-降维">根据 <strong><em>dim</em></strong> 降维</h4><p><strong><em>xarray.mean( dim )</em></strong></p><p>除了使用类似于numpy中的对数轴的降维方法，也可以使用xarray中独特、便捷的方法。这种方法无需记忆数轴所对应的维度名称。</p><p>若要求解多年SST的平均场，可以通过对时间维取平均降维实现。这可以定义dim这个参数实现。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sst.mean(dim=<span class="string">"time"</span>).coords</span><br></pre></td></tr></table></figure><p>当然除了mean方法，其他的numpy标准降维方法也是可以使用的，如min（取最小值）, max（取最大值）, sum（求和）, std（求解标准差）等。</p><h4 id="控制缺失值-skipna">控制缺失值 <strong><em>skipna</em></strong></h4><p>上述这些操作会自动跳过缺失值，这对于某些数据的处理是非常有利的，比如SST仅在海洋上有值，但陆地上没有值，利用.mean进行计算时会自动忽略缺失值。</p><p>为进一步说明，下面举一个例子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xr.DataArray([<span class="number">1</span>, <span class="number">2</span>, np.nan, <span class="number">3</span>]).mean()</span><br></pre></td></tr></table></figure><p>如果要考虑缺失值的计算（虽然通常没有此类需求），则需在括号中添加参数skipna=False.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xr.DataArray([<span class="number">1</span>, <span class="number">2</span>, np.nan, <span class="number">3</span>]).mean(skipna=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><h4 id="练习---1">练习 - 1</h4><p>在经度和纬度上均取变量sst的平均值。绘制一个简单的时间序列图：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在这里写你的代码</span></span><br><span class="line">sst.mean(dim=(<span class="string">"lat"</span>, <span class="string">"lon"</span>)).plot()</span><br></pre></td></tr></table></figure><h3 id="广播">广播</h3><p>广播（Broadcasting）是指具有不同维度数组的对齐。</p><p>基于数组形状的 Numpy 广播规则有时可能难以理解和记住，<br>Xarray相较Numpy提供了按维度名称（而非数组形状）进行广播的方法，免去了记忆的困难。</p><p>为说明广播在计算中的作用，下面将创建一个与纬度有关的权重因子。这个权重因子常用于描述规则经纬网格上数据的面积权重系数。</p><p>下述的代码创建了一个权重系数，ds.lat可以获取ds的纬度数组（离散角度值）。因为后续的np.cos()只能接受弧度进行计算，这儿利用np.deg2rad函数将角度转换为弧度，再利用np.cos()计算余弦值。</p><p>总而言之，本质上权重系数即为各个纬度上的余弦值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">weights = np.cos(np.deg2rad(ds.lat))</span><br><span class="line">weights.coords</span><br></pre></td></tr></table></figure><p>此时，权重因子仅有一个维度。如果我们将这个权重因子与SST相乘会发生什么呢？</p><p>应当注意这个相乘不是矩阵相乘，而是对应位置的元素彼此相乘。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(ds.sst * weights).coords</span><br></pre></td></tr></table></figure><p>如果要广播的数组共享一个维度名称，但坐标维度不同。<br>在这种情况下，广播将会使用xarray的默认对齐设置（即取两者变量索引的交集）进行对齐（包括使用NaN填充缺失值）。</p><p>如果这不是想要的结果，最好在广播之前显式调用 <strong><em>align</em></strong> 并指定参数使得两个数组得以对齐。</p><h3 id="赋权降维">赋权降维</h3><p><strong><em>DataArray.weighted( weights ) , Dataset.weighted( weights )</em></strong></p><p>xarray目前支持DataArray和Dataset对象，对于这两个对象的赋权降维可采用 DataArray.weighted() 和 Dataset.weighted() 方法。<br>目前支持带权重的以平均（mean）和求和（sum）方法降维。</p><p>为说明赋权降维，下面先创建一个关于降水数据的DataArray和一个权重的DataArray.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">prec = xr.DataArray(</span><br><span class="line">    [<span class="number">50</span>, <span class="number">10</span>, <span class="number">0.9</span>], </span><br><span class="line">    dims=(<span class="string">"month"</span>), </span><br><span class="line">    coords= {<span class="string">"month"</span>:(<span class="string">"month"</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])}</span><br><span class="line">    )</span><br><span class="line">prec.coords</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">weights = xr.DataArray(</span><br><span class="line">    [<span class="number">31</span>, <span class="number">28</span>, <span class="number">31</span>], </span><br><span class="line">    dims=(<span class="string">"month"</span>), </span><br><span class="line">    coords= {<span class="string">"month"</span>:(<span class="string">"month"</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])}</span><br><span class="line">    )</span><br><span class="line">weights</span><br></pre></td></tr></table></figure><p>接下来对prec以weights为权重创建权重对象</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">weighted_prec = prec.weighted(weights)</span><br><span class="line">weighted_prec</span><br></pre></td></tr></table></figure><p>计算加权和：50x31 + 10x28 + 0.9x31</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">weighted_prec.<span class="built_in">sum</span>()</span><br></pre></td></tr></table></figure><p>等价于：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(prec*weights).<span class="built_in">sum</span>()</span><br></pre></td></tr></table></figure><p>计算加权平均：( 50x31 + 10x28 + 0.9x31 ) / (31+28+31)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">weighted_prec.mean(dim = <span class="string">"month"</span>)</span><br></pre></td></tr></table></figure><p>等价于：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(prec*weights).<span class="built_in">sum</span>() / weights.<span class="built_in">sum</span>()</span><br></pre></td></tr></table></figure><h4 id="源数据存在-缺失值和某些特殊计算的情况">源数据存在 缺失值和某些特殊计算的情况</h4><p>如果原数据存在缺失值np.nan时，赋权降维将得到正确的结果。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data = xr.DataArray([np.nan, <span class="number">2</span>, <span class="number">4</span>])</span><br><span class="line">weights = xr.DataArray([<span class="number">8</span>, <span class="number">1</span>, <span class="number">1</span>])</span><br><span class="line">data.weighted(weights).mean()</span><br></pre></td></tr></table></figure><p>而利用 (data * weights).sum() / weights.sum() 公式进行计算，得到的结果是不正确的<br>不正确的原因在于某一点没有值，但其权重却参与了计算，会使得整体值减小。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(data*weights).<span class="built_in">sum</span>()/weights.<span class="built_in">sum</span>()</span><br></pre></td></tr></table></figure><h4 id="实际案例平均sst的计算">实际案例：平均SST的计算</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 数据导入</span></span><br><span class="line">path = <span class="string">".data/sst.mnmean.nc"</span></span><br><span class="line">p = <span class="string">'#ff9988'</span></span><br><span class="line"><span class="comment"># 丢弃一个不必要导入的变量</span></span><br><span class="line">ds = xr.open_dataset(path, drop_variables=[<span class="string">"time_bnds"</span>])</span><br><span class="line">ds = ds.sel(time=<span class="built_in">slice</span>(<span class="string">"1960"</span>, <span class="string">"2018"</span>)).load()</span><br><span class="line">weights = np.cos(np.deg2rad(ds.lat))</span><br></pre></td></tr></table></figure><p>尝试一下以下方法对带权重的空间平均SST进行计算，就如下述代码所示</p><p>没有考虑缺厕值问题，导致结果偏小</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sst_mean = ((ds.sst * weights).<span class="built_in">sum</span>(dim=<span class="string">"lat"</span>) / weights.<span class="built_in">sum</span>(dim=<span class="string">"lat"</span>)).mean(dim=<span class="string">"lon"</span>)</span><br><span class="line">sst_mean.plot()</span><br><span class="line">plt.title(<span class="string">"This is wrong!"</span>)</span><br></pre></td></tr></table></figure><p>就一般而言，多维数组上的赋权降维是复杂的。为了使操作更简单，xarray提供了一种赋权降维的机制。<br>这个机制通过创建一个特殊的中间DataArrayWeighted对象来实现这个目的，从而能够对数组使用各类的降维操作。</p><p>下述代码对DataArray对象给予了.weighted()方法，括号内填入了权重。</p><p>运行的结果创建了一个关于DataArray的权重对象（DataArrayWeighted），并且这个权重是伴随着维度lat（纬度）变化的。</p><p>接着对DataArray这个权重对象同时在在维度lon, lat上取平均。这时我们便获得了一个正确的全球平均SST.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sst_weighted = ds.sst.weighted(weights)</span><br><span class="line">sst_weighted.mean(dim=(<span class="string">"lon"</span>, <span class="string">"lat"</span>)).plot()</span><br><span class="line">plt.title(<span class="string">"Correct Global Mean SST"</span>)</span><br></pre></td></tr></table></figure><h2 id="groupby-分组">Groupby 分组</h2><p>Groupby是Pandas包中比较重要的一种聚合方法<br>xarray借鉴了Pandas包中groupby功能，在xarray的DataArrays和Datasets上实现分割（split）、应用（apply） 和 组合（combine）</p><p>为提供一个实际案例，下面考虑某个格点上的SST时间序列。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ds.sst.sel(lon=<span class="number">300</span>, lat=<span class="number">50</span>).plot()</span><br></pre></td></tr></table></figure><h3 id="根据时间分组">根据时间分组</h3><h4 id="创建时间变量的-待索引对象">创建时间变量的 <strong>待索引对象</strong></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ds.time.dt</span><br></pre></td></tr></table></figure><p>利用.dt.month提取各个时间的月份数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ds.time.dt.month.shape <span class="comment">#提取月份</span></span><br></pre></td></tr></table></figure><p>利用.dt.year提取各个时间的年份数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ds.time.dt.year.shape <span class="comment"># 提取年</span></span><br></pre></td></tr></table></figure><h4 id="根据时间索引创建-groupby对象">根据时间索引，创建 <strong>groupby对象</strong></h4><p><strong><em>ds.groupby( ds.time.dt.month )</em></strong><br><strong><em>ds.groupby( "time.month" )</em></strong></p><p>类似于Pandas包中的groupby的思想，我们利用ds.groupby()函数将月份作为键（唯一值）来对原数据进行分离。<br>本质是即把各年的某个月的数据放到了一组。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gb = ds.groupby(ds.time.dt.month) <span class="comment"># 根据月份进行分组</span></span><br><span class="line">gb</span><br></pre></td></tr></table></figure><p>如果说时间参数变量已经包含在原数据集中（这也是通常出现的情况），可以使用xarray中更为简洁的方法，即"time.month". 这与ds.time.dt.month实现的操作是一致的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gb = ds.groupby(<span class="string">"time.month"</span>)</span><br><span class="line">gb</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ds.groupby(<span class="string">"time.year"</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ds.groupby(<span class="string">"time.season"</span>)</span><br></pre></td></tr></table></figure><h4 id="迭代访问-groupby对象">迭代访问 <strong>groupby对象</strong></h4><p>经过上面的分组操作后，原数据已经拆分成12个组（groups），放置在变量gb中。<br>对于这12个组，可通过循环进行遍历。迭代器返回各个组的键（组名）和值（与该组相对应的实际数据集）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> group_name, group_ds <span class="keyword">in</span> gb:</span><br><span class="line">    <span class="comment"># 当第一个循环结束时，停止遍历gb</span></span><br><span class="line">    display(group_ds) </span><br><span class="line">    <span class="keyword">break</span></span><br></pre></td></tr></table></figure><h4 id="逐个访问-groupby对象">逐个访问 <strong>groupby对象</strong></h4><p>除了可以使用循环的方法对各个分组进行遍历，也可直接使用python中 <strong>列表</strong> 的访问方法访问各个分组。<br>通过对list对象的第一个分组的访问可以获得分组名称和对应的xarray数据.</p><p>先来尝试访问一下第一个（python中的第一个元素的索引由0开始）分组的信息</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span>(gb)[<span class="number">0</span>] <span class="comment">#访问第一个分组</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span>(gb)[<span class="number">0</span>][<span class="number">0</span>] <span class="comment"># 第一个分组的名称</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span>(gb)[<span class="number">0</span>][<span class="number">1</span>] <span class="comment"># 第一个分组的数据</span></span><br></pre></td></tr></table></figure><p>我们可以对上述的三步简写为</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span>(gb)[<span class="number">0</span>][<span class="number">1</span>] <span class="comment"># 等效为list_first_group[1]</span></span><br></pre></td></tr></table></figure><h4 id="查找各个分组中对应元素在原始数据中键的位置">查找各个分组中对应元素在原始数据中键的位置</h4><p><strong><em>groupby.groups</em></strong></p><p>以 字典 形式返回各个分组（在这儿是month）中的元素在原分组坐标中（在这儿是time）的位置</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gb.groups.keys()</span><br></pre></td></tr></table></figure><p>上述说明了gb将数据分为了12组，每个组的名字分别为1、2……12，其中名字为1的组（即一月）中包含了时间序列中第0个、第12个……<br>时间序列中第0个可理解为ds.isel(time = 0)，同理第12个可理解为ds.isel(time = 12).</p><h3 id="分箱binning">分箱（Binning）</h3><p>分箱（Binning），顾名思义如果要对数据进行筛选，可以指定分箱规则对数据进行筛选。<br>分箱与分割有所不同。分箱针对的对象是对数据指定规则，而分割针对维度坐标指定规则。<br>xarray中的分箱方法基于pandas.cut()实现</p><p>以 筛选出数据第0时刻 海温低于零摄氏度的格点位置和相应的海温数据 为例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ds_0 = ds.isel(time = [<span class="number">0</span>])</span><br></pre></td></tr></table></figure><h4 id="根据分箱创建-groupby对象">根据分箱，创建 <strong>groupby对象</strong></h4><p><strong><em>ds.groupby_bins( data_var, bin, labels )</em></strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sst_bin = [-<span class="number">10</span>, <span class="number">0</span>, <span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>] <span class="comment"># sst_bin是声明的分箱数组的间隔段。</span></span><br><span class="line">sst_bin_label = [<span class="string">"-10℃-0℃"</span>, <span class="string">"0℃-10℃"</span>, <span class="string">"10℃-20℃"</span>, <span class="string">"20℃-30℃"</span>] <span class="comment"># sst_bin_label指定了每一个分箱区间的标签，</span></span><br><span class="line"><span class="comment"># 如果不想手动指定，在.groupby_bins方法中不写labels参数即可，这时候将由pandas.cut分配标签。</span></span><br><span class="line">sst_gb = ds_0.groupby_bins(<span class="string">"sst"</span>, sst_bin, labels = sst_bin_label)</span><br><span class="line"><span class="comment"># .groupby_bins方法即对数据进行分箱的方法，应当指出分箱的方法的作用对象为DataSet而非DataArray </span></span><br><span class="line"><span class="comment"># 方法的第一个参数sst表明对mydatasplit这个DataSet对象的sst变量进行分箱。而后的sst_bin定义了如何进行分箱。labels定义了各个箱子的标签。</span></span><br></pre></td></tr></table></figure><h4 id="迭代访问-groupby-对象">迭代访问 <strong>groupby 对象</strong></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> group_name, group_ds <span class="keyword">in</span> sst_gb:</span><br><span class="line">    display(group_ds)</span><br><span class="line">    <span class="keyword">break</span></span><br></pre></td></tr></table></figure><h4 id="逐个访问-groupby-对象">逐个访问 <strong>groupby 对象</strong></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span>(sst_gb)[<span class="number">0</span>][<span class="number">1</span>]</span><br></pre></td></tr></table></figure><h4 id="查看分箱名称及其数据在原始数据对应的位置">查看分箱名称及其数据在原始数据对应的位置</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sst_gb_bin = gb.groups </span><br><span class="line"><span class="comment"># 与分组一节中对gb查找原始键类似，这里对groupby对象（即data0.groupby_bins("sst", sst_bin, labels = sst_bin_label)）</span></span><br><span class="line"><span class="comment"># 添加.groups方法能够获取对应的原始位置。</span></span><br><span class="line"><span class="comment"># gb_bin</span></span><br></pre></td></tr></table></figure><h3 id="groupby-的应用">Groupby 的应用</h3><p>累计：合并分组成为完整的一组<br>转换：对各个分组分别给予计算</p><p>对于应用步骤而言，使用的方法是 .map（映射）.</p><h4 id="累计降维">累计（“降维”）</h4><p><strong><em>groupby.map( function )</em></strong></p><p>对于累计方法，以求解多年各月sst平均空间场为例说明累计的实现方法。</p><p>.map可接受一个 函数 作为其参数。下面我们来传递一个求平均的参数np.mean（此处的函数无括号）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gb = ds.groupby(<span class="string">"time.month"</span>) <span class="comment">#导入分组数据</span></span><br><span class="line">time_mean = <span class="keyword">lambda</span> a: a.mean(dim=<span class="string">"time"</span>)</span><br><span class="line">gb.<span class="built_in">map</span>(time_mean)</span><br></pre></td></tr></table></figure><p>与Pandas包一样，xarray的groupby对象也内置许多的累计（aggregation）操作（如mean, min, max, std等）.<br>这些内置操作能够简化上述常用操作代码的书写。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这与上述的自定义函数的功能相同</span></span><br><span class="line">gb.mean(dim=<span class="string">"time"</span>)</span><br></pre></td></tr></table></figure><p>对于分组方案中的每一个分组都作用.mean降维方法，然后通过自动组合的方式得到最后的统一的数据集monthsst。<br>这个数据集可以通过month索引多年各个月份的数据。</p><p>接下来试着做一下数据的累计操作，并绘图。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 北大西洋特定格点的多年月平均气候序列</span></span><br><span class="line">gb.mean(dim=<span class="string">"time"</span>).sst.sel(lon=<span class="number">300</span>, lat=<span class="number">50</span>).plot()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 多年纬度月平均气候场</span></span><br><span class="line">gb.mean(dim=<span class="string">"time"</span>).sst.mean(dim=<span class="string">"lon"</span>).plot.contourf(x=<span class="string">"month"</span>, levels=<span class="number">12</span>, vmin=-<span class="number">2</span>, vmax=<span class="number">30</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 多年1月与7月平均气候场之间的差异</span></span><br><span class="line">(gb.mean(dim=<span class="string">"time"</span>).sst.sel(month=<span class="number">1</span>) - gb.mean(dim=<span class="string">"time"</span>).sst.sel(month=<span class="number">7</span>)).plot.contourf(vmax=<span class="number">10</span>)</span><br></pre></td></tr></table></figure><h4 id="转换">转换</h4><p>下面需从数据集中删除气候平均，从而得到变量随气候平均态变化的残差。一般将这个残差称为距平。</p><p>对转换（Transformations）操作而言，消除数据的气候平均是一个很好的例子。<br>转换操作对分组的对象进行操作，但不改变原数据的维度尺寸。</p><p>xarray 通过使用Groupby 算法使这些类型的转换变得容易。下面给出了计算去除月份温度差异的海温月数据。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对 12 组中的对应组的海温数据（这个组内的每一天的海温数据）减去平均的海温数据</span></span><br><span class="line">remove_time_mean = <span class="keyword">lambda</span> a: a-a.mean(dim=<span class="string">"time"</span>)</span><br><span class="line">gb.<span class="built_in">map</span>(remove_time_mean)</span><br></pre></td></tr></table></figure><p>也可以简写为下面这种形式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对 12 组中的对应组的海温数据（这个组内的每一天的海温数据）减去平均的海温数据</span></span><br><span class="line">ds_anom = gb - gb.mean(dim=<span class="string">"time"</span>)</span><br><span class="line">ds_anom</span><br></pre></td></tr></table></figure><p>当经过上述去除季节性周期的影响后，便很容易发现气候变率的信号。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 北大西洋单点的时间序列</span></span><br><span class="line">ds_anom.sst.sel(lon=<span class="number">300</span>, lat=<span class="number">50</span>).plot()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 2018 年 1 月 1 日与 1960 年 1 月 1 日之间 SST 之间的差异</span></span><br><span class="line">(ds_anom.sel(time=<span class="string">"2018-01-01"</span>) - ds_anom.sel(time=<span class="string">"1960-01-01"</span>)).sst.plot()</span><br></pre></td></tr></table></figure><h2 id="resample重采样">Resample重采样</h2><p>xarray 中的Resample（重采样）的处理方法与 Pandas 包几乎相同。就本质而言，Resample 也是一个分割数据的操作。<br>它与分割操作的基本语法类似。应当注意，对于 Resample 操作而言，其作用对象必须是时间维度。</p><p><strong><em>ds.resample( time="freq" )</em></strong></p><p>为说明 Resample 的用法，下面给出一个例子计算逐五年的平均值曲线。</p><p>对于 Resample 操作而言，与 Groupby 操作非常类似，首先也创建了一个DatasetResample对象。<br>.resample(time="5Y")是对时间进行重采样进行设置，维度为time，设置的时间间隔为 5 年。<br>应当指出这里的时间间隔写法与之前pd.date_range函数中的freq的时间间隔的关键词是一致的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">resample_obj = ds_anom.resample(time=<span class="string">"5Y"</span>)</span><br><span class="line">resample_obj</span><br></pre></td></tr></table></figure><p>然后对这些分割好的 Resample 对象进行取平均，以便获得每一个分组好的 Resample 对象中的平均值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ds_anom_resample = resample_obj.mean(dim=<span class="string">"time"</span>)</span><br><span class="line">ds_anom_resample</span><br></pre></td></tr></table></figure><p>为了说明进行重采样后的效果，下面来看一下(50°N, 60°E)的海温变化情况</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 原始海温变化的时间序列</span></span><br><span class="line">ds_anom.sst.sel(lon=<span class="number">300</span>, lat=<span class="number">50</span>).plot() </span><br><span class="line"><span class="comment"># 逐5年平均的海温变化的时间序列</span></span><br><span class="line">ds_anom_resample.sst.sel(lon=<span class="number">300</span>, lat=<span class="number">50</span>).plot(marker=<span class="string">"o"</span>) </span><br></pre></td></tr></table></figure><h2 id="coarsen粗化">Coarsen（粗化）</h2><p>coarsen（粗化）所做的事情与resample（重采样）类似。<br>resample仅可用于时间坐标，但coarsen对逻辑坐标和时间坐标均可使用。<br>同时coarsen不仅能作用一个维度，还可作用多个维度。粗化方法通常用来降低xarray对象的分辨率。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ds_anom.sst.isel(time = <span class="number">0</span>).coords</span><br></pre></td></tr></table></figure><p>采用粗化的方法将其重采样至 5×10 的分辨率</p><p><strong><em>ds.coarsen( dim1=size1, dim2=size2, ..., boundary )</em></strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ds_anom.sst.coarsen(</span><br><span class="line">    lat=<span class="number">5</span>, </span><br><span class="line">    lon=<span class="number">10</span>, </span><br><span class="line">    boundary=<span class="string">"trim"</span></span><br><span class="line">).mean().isel(time=<span class="number">0</span>).plot()</span><br></pre></td></tr></table></figure><p>boundary 变量规定了如何处理数组尺寸与窗口尺寸之间不是倍数的情况。<br>若为trim，多余的不能整除的数据将被直接剔除；若为pad，则将其填充为 nan.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ds_anom.sst.coarsen(</span><br><span class="line">    lat=<span class="number">5</span>, </span><br><span class="line">    lon=<span class="number">10</span>, </span><br><span class="line">    boundary=<span class="string">"pad"</span></span><br><span class="line">).mean().isel(time=<span class="number">0</span>).plot()</span><br></pre></td></tr></table></figure><p>对时间维的重采样，resample和coarsen均可有类似的结果。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ds_anom_ = ds_anom.sst.sel(lon=<span class="number">300</span>, lat=<span class="number">50</span>)</span><br><span class="line">ds_anom_.coarsen (time=<span class="number">12</span>, boundary= <span class="string">"pad"</span>).mean().plot(c=<span class="string">"r"</span>)</span><br><span class="line">ds_anom_.resample(time=<span class="string">"Y"</span>).mean().plot(c=<span class="string">"b"</span>)</span><br></pre></td></tr></table></figure><p>最后对比一下逐12个日期平均和12个月滑动平均的曲线</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 5年平均序列 coarsen</span></span><br><span class="line">ds_anom_coarsen_time = ds_anom.coarsen(time=<span class="number">12</span>*<span class="number">5</span>, boundary=<span class="string">"pad"</span>).mean()</span><br><span class="line">ds_anom_coarsen_time.sst.sel(lon=<span class="number">300</span>, lat=<span class="number">50</span>).plot(c=<span class="string">"r"</span>)</span><br><span class="line"><span class="comment"># 5年平均序列 resample</span></span><br><span class="line">ds_anom_coarsen_time = ds_anom.resample(time=<span class="string">"5Y"</span>, closed=<span class="string">"left"</span>).mean()</span><br><span class="line">ds_anom_coarsen_time.sst.sel(lon=<span class="number">300</span>, lat=<span class="number">50</span>).plot(c=<span class="string">"b"</span>)</span><br><span class="line"><span class="comment"># 5年滑动平均</span></span><br><span class="line">ds_anom_rolling = ds_anom.rolling(time=<span class="number">12</span>*<span class="number">5</span>).mean()</span><br><span class="line">ds_anom_rolling.sst.sel(lon=<span class="number">300</span>, lat=<span class="number">50</span>).plot(c=<span class="string">"k"</span>)</span><br></pre></td></tr></table></figure><h2 id="rolling-滑动平均">Rolling 滑动平均</h2><p>Rolling 方法也与pandas 包中的类似，但是稍有不同的是，它可适用于任意维度。如果将其作用于时间维度，也可称之为滑动平均。</p><p><strong><em>ds.rolling( dim, center )</em></strong></p><p>time=12指定了对维度time以 12 个月为周期（月数据）变动时间窗，<br>center=True表明以当前窗的两侧筛选数据，否则是以当前窗的前 12 个月作为筛选目标（包括本身）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ds_anom_rolling = ds_anom.rolling(time=<span class="number">12</span>*<span class="number">5</span>, center=<span class="literal">True</span>).mean()</span><br><span class="line">ds_anom_rolling</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 原始海温变化的时间序列</span></span><br><span class="line">ds_anom.sst.sel(lon=<span class="number">300</span>, lat=<span class="number">50</span>).plot(color=<span class="string">"#CCCCCC"</span>) </span><br><span class="line"><span class="comment"># 5年滑动平均的海温变化的时间序列</span></span><br><span class="line">ds_anom_rolling.sst.sel(lon=<span class="number">300</span>, lat=<span class="number">50</span>).plot(color=<span class="string">"#E54E35"</span>, linewidth=<span class="number">3</span>) </span><br><span class="line"><span class="comment"># 逐5年平均的海温变化的时间序列</span></span><br><span class="line">ds_anom_resample.sst.sel(lon=<span class="number">300</span>, lat=<span class="number">50</span>).plot(color=<span class="string">"#3FAA59"</span>, marker=<span class="string">"o"</span>, linewidth=<span class="number">3</span>) </span><br></pre></td></tr></table></figure><h3 id="为了更好的说明-rolling-的作用下面举一个简单的例子说明其功能">为了更好的说明 Rolling 的作用，下面举一个简单的例子说明其功能</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">da = xr.DataArray(</span><br><span class="line">    np.linspace(<span class="number">0</span>, <span class="number">11</span>, <span class="number">12</span>),</span><br><span class="line">    dims=<span class="string">"time"</span>,</span><br><span class="line">    coords=[</span><br><span class="line">        pd.date_range(<span class="string">"1999-12-15"</span>,periods=<span class="number">12</span>,freq=pd.DateOffset(months=<span class="number">1</span>))</span><br><span class="line">    ]</span><br><span class="line">)</span><br><span class="line">da</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">da.rolling(time=<span class="number">5</span>, center=<span class="literal">True</span>).mean()</span><br></pre></td></tr></table></figure><p>若时间窗为偶数值，那么对应中心位置将会在平均位置偏右侧</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">da.rolling(time=<span class="number">4</span>, center=<span class="literal">True</span>).mean()</span><br></pre></td></tr></table></figure><p>若不指定参数center=True，则采用从当前元素往前筛选的方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">da.rolling(time=<span class="number">5</span>).mean()</span><br></pre></td></tr></table></figure><p>当然和 grouby 对象类似，也可用 list 来访问每一个滑动窗</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rolling_obj = da.rolling(time=<span class="number">5</span>)</span><br><span class="line"><span class="built_in">list</span>(rolling_obj)[<span class="number">4</span>][<span class="number">1</span>]</span><br></pre></td></tr></table></figure><h2 id="线性多项式回归">线性多项式回归</h2><p>.polyfit方法实现了回归功能，<br>第一个参数"time"指定拟合坐标为time，<br>第二数字参数指定为一元线性回归，<br>full = True代表回归方法不仅要返回拟合系数（一元回归即斜率和截距）还应当返回残差，矩阵秩和奇异值。</p><p><strong><em>ds.polyfit( dim, degree, full )</em></strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ds_poly = ds_anom.sst.polyfit(<span class="string">"time"</span>, <span class="number">1</span>, full=<span class="literal">True</span>)</span><br><span class="line">ds_poly</span><br></pre></td></tr></table></figure><p>线性趋势（斜率）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ds_poly.polyfit_coefficients.isel(degree=<span class="number">0</span>).plot()</span><br></pre></td></tr></table></figure><p>截距空间分布</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ds_poly.polyfit_coefficients.isel(degree=<span class="number">1</span>).plot()</span><br></pre></td></tr></table></figure></div><footer class="post-footer"><div class="reward-container"><div>您的支持是我创作的最大动力！</div><button>赞赏</button><div class="post-reward"><div><img src="/images/wechatpay.png" alt="BUUJUN WANG 微信"> <span>微信</span></div><div><img src="/images/alipay.png" alt="BUUJUN WANG 支付宝"> <span>支付宝</span></div></div></div><div class="post-copyright"><ul><li class="post-copyright-author"><strong>本文作者： </strong>BUUJUN WANG</li><li class="post-copyright-link"><strong>本文链接：</strong> <a href="https://buujun.fun/xarray/ch2-calculate/" title="Xarray - 计算">https://buujun.fun/xarray/ch2-calculate/</a></li><li class="post-copyright-license"><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><div class="post-tags"><a href="/tags/python/" rel="tag"># python</a> <a href="/tags/numpy/" rel="tag"># numpy</a> <a href="/tags/pandas/" rel="tag"># pandas</a> <a href="/tags/matplotlib/" rel="tag"># matplotlib</a> <a href="/tags/xarray/" rel="tag"># xarray</a></div><div class="post-nav"><div class="post-nav-item"><a href="/xarray/ch1-basics/" rel="prev" title="Xarray - 数据对象"><i class="fa fa-chevron-left"></i> Xarray - 数据对象</a></div><div class="post-nav-item"><a href="/cdo/cdo_%E5%A4%84%E7%90%86CMIP6/" rel="next" title="CDO - 处理 CMIP6 实战">CDO - 处理 CMIP6 实战 <i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><div class="comments gitalk-container"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2022</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">BUUJUN WANG</span></div></div></footer><script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js" integrity="sha256-yt2kYMy0w8AbtF89WXb2P1rfjcP/HTHLT7097U8Y5b8=" crossorigin="anonymous"></script><script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/next-boot.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.0/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script><script src="/js/third-party/search/local-search.js"></script><script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"default","dark":"dark"},"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mermaid/9.1.3/mermaid.min.js","integrity":"sha256-TIYL00Rhw/8WaoUhYTLX9SKIEFdXxg+yMWSLVUbhiLg="}}</script><script src="/js/third-party/tags/mermaid.js"></script><script src="/js/third-party/fancybox.js"></script><script src="//cdn.jsdelivr.net/npm/quicklink@1/dist/quicklink.umd.js"></script><script class="next-config" data-name="quicklink" type="application/json">{"enable":true,"home":true,"archive":true,"delay":true,"timeout":3000,"priority":true,"url":"https://buujun.fun/xarray/ch2-calculate/"}</script><script src="/js/third-party/quicklink.js"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/gitalk/1.7.2/gitalk.css" integrity="sha256-AJnUHL7dBv6PGaeyPQJcgQPDjt/Hn/PvYZde1iqfp8U=" crossorigin="anonymous"><script class="next-config" data-name="gitalk" type="application/json">{"enable":true,"github_id":"buujun","repo":"buujun.fun","client_id":"3eb99aceb51107a24ac3","client_secret":"62131dae4253e8e6a40eeef79c655accf35fc43d","admin_user":"buujun","distraction_free_mode":true,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token","language":"zh-CN","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/gitalk/1.7.2/gitalk.min.js","integrity":"sha256-Pmj85ojLaPOWwRtlMJwmezB/Qg8BzvJp5eTzvXaYAfA="},"path_md5":"38a092f4e00c0c0fdfefb6efd7683a45"}</script><script src="/js/third-party/comments/gitalk.js"></script><script async src="/js/cursor/fireworks.js"></script><script src="/js/activate-power-mode.min.js"></script><script>POWERMODE.colorful=!0,POWERMODE.shake=!1,document.body.addEventListener("input",POWERMODE)</script></body></html>